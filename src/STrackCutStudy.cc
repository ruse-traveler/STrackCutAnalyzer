// ----------------------------------------------------------------------------
// 'STrackCutStudy.cc'
// Derek Anderson
// 12.15.2022
//
// Reads in the 'ntp_track' Ntuple
// generated by the SVtxEvaluator
// class and studies the impact
// of cutting on various quantities.
// ----------------------------------------------------------------------------

#define STRACKCUTSTUDY_CC

// header files
#include "STrackCutStudy.h"
#include "STrackCutStudy.io.h"
#include "STrackCutStudy.ana.h"
#include "STrackCutStudy.hist.h"
#include "STrackCutStudy.plot.h"

using namespace std;



// ctor/dtor ------------------------------------------------------------------

STrackCutStudy::STrackCutStudy() {

  sTxtEO.clear();
  sTxtPU.clear();
  nTxtEO          = 0;
  nTxtPU          = 0;
  doIntNorm       = false;
  doAvgClustCalc  = false;
  normalPtFracMin = 0.;
  normalPtFracMax = 9999.;
  doPrimaryCut    = false;
  doMVtxCut       = false;
  doVzCut         = false;
  doDcaXyCut      = false;
  doDcaZCut       = false;
  doQualityCut    = false;
  cout << "\n  Beginning track cut study."  << endl;

}  // end ctor




STrackCutStudy::~STrackCutStudy() {

  const bool doTuplesExist = (ntTrkEO || ntTrkPU);
  if (!doTuplesExist) {
    return;
  } else {
    delete ntTrkEO -> GetCurrentFile();
    delete ntTrkPU -> GetCurrentFile();
  }

}  // end dtor



//  main methods --------------------------------------------------------------

void STrackCutStudy::Init() {

  // announce method
  cout << "    Initializing:" << endl;
  InitFiles();
  InitTuples();
  InitHists();
  MakeCutText();
  return;

}  // end Init()



void STrackCutStudy::Analyze() {

  // check for tree and announce method
  const bool doTuplesExist = (ntTrkEO && ntTrkPU);
  if (!doTuplesExist) {
    cerr << "PANIC: no input tuples!\n"
         << "        ntTrkEO = " << ntTrkEO << ", ntTrkPU = " << ntTrkPU
         << endl;
    assert(doTuplesExist);
  }
  cout << "    Analyzing:" <<endl;

  // prepare for embed-only entry loop
  Long64_t nEntriesEO = ntTrkEO -> GetEntries();
  cout << "      Beginning embed-only entry loop: " << nEntriesEO << " entries to process..." << endl;

  // arrays for filling histograms
  Double_t recoTrkVars[NTrkVar];
  Double_t trueTrkVars[NTrkVar];
  Double_t recoPhysVars[NPhysVar];
  Double_t truePhysVars[NPhysVar];

  // loop over embed-only tuple entries
  Long64_t nBytesEO(0);
  for (Long64_t iEntry = 0; iEntry < nEntriesEO; iEntry++) {

    // grab entry
    const Long64_t bytesEO = ntTrkEO -> GetEntry(iEntry);
    if (bytesEO < 0.) {
      cerr << "WARNING: something wrong with embed-only entry #" << iEntry << "! Aborting loop!" << endl;
      break;
    }
    nBytesEO += bytesEO;

    // announce progress
    const Long64_t iProg = iEntry + 1;
    if (iProg == nEntriesEO) {
      cout << "        Processing embed-only entry " << iProg << "/" << nEntriesEO << "..." << endl;
    } else {
      cout << "        Processing embed-only entry " << iProg << "/" << nEntriesEO << "...\r" << flush;
    }

    // perform calculations
    const Double_t umDcaXY    = dca3dxy * 10000;
    const Double_t umDcaZ     = dca3dz * 10000;
    const Double_t deltaDcaXY = abs(dca3dxysigma / dca3dxy);
    const Double_t deltaDcaZ  = abs(dca3dzsigma / dca3dz);
    const Double_t deltaEta   = abs(deltaeta / eta);
    const Double_t deltaPhi   = abs(deltaphi / phi);
    const Double_t deltaPt    = abs(deltapt / pt);
    const Double_t ptFrac     = pt /gpt;

    // set reco track variables
    recoTrkVars[TRKVAR::VX]       = vx;
    recoTrkVars[TRKVAR::VY]       = vy;
    recoTrkVars[TRKVAR::VZ]       = vz;
    recoTrkVars[TRKVAR::NMMS]     = (Double_t) nlmms;
    recoTrkVars[TRKVAR::NMAP]     = (Double_t) nlmaps;
    recoTrkVars[TRKVAR::NINT]     = (Double_t) nlintt;
    recoTrkVars[TRKVAR::NTPC]     = (Double_t) ntpc;
    recoTrkVars[TRKVAR::QUAL]     = quality;
    recoTrkVars[TRKVAR::DCAXY]    = umDcaXY;
    recoTrkVars[TRKVAR::DCAZ]     = umDcaZ;
    recoTrkVars[TRKVAR::DELDCAXY] = deltaDcaXY;
    recoTrkVars[TRKVAR::DELDCAZ]  = deltaDcaZ;
    recoTrkVars[TRKVAR::NCLUST]   = 0.;
    recoTrkVars[TRKVAR::AVGCLUST] = 0.;

    // set true track variables
    trueTrkVars[TRKVAR::VX]       = gvx;
    trueTrkVars[TRKVAR::VY]       = gvy;
    trueTrkVars[TRKVAR::VZ]       = gvz;
    trueTrkVars[TRKVAR::NMMS]     = (Double_t) gnlmms;
    trueTrkVars[TRKVAR::NMAP]     = (Double_t) gnlmaps;
    trueTrkVars[TRKVAR::NINT]     = (Double_t) gnlintt;
    trueTrkVars[TRKVAR::NTPC]     = (Double_t) gntpc;
    trueTrkVars[TRKVAR::QUAL]     = quality;
    trueTrkVars[TRKVAR::DCAXY]    = umDcaXY;
    trueTrkVars[TRKVAR::DCAZ]     = umDcaZ;
    trueTrkVars[TRKVAR::DELDCAXY] = deltaDcaXY;
    trueTrkVars[TRKVAR::DELDCAZ]  = deltaDcaZ;
    trueTrkVars[TRKVAR::NCLUST]   = 0.;
    trueTrkVars[TRKVAR::AVGCLUST] = 0.;

    // set reco phys variables
    recoPhysVars[PHYSVAR::PHI]    = phi;
    recoPhysVars[PHYSVAR::ETA]    = eta;
    recoPhysVars[PHYSVAR::PT]     = pt;
    recoPhysVars[PHYSVAR::DELPHI] = deltaPhi;
    recoPhysVars[PHYSVAR::DELETA] = deltaEta;
    recoPhysVars[PHYSVAR::DELPT]  = deltaPt;

    // set true phys variables
    truePhysVars[PHYSVAR::PHI]    = gphi;
    truePhysVars[PHYSVAR::ETA]    = geta;
    truePhysVars[PHYSVAR::PT]     = gpt;
    truePhysVars[PHYSVAR::DELPHI] = deltaPhi;
    truePhysVars[PHYSVAR::DELETA] = deltaEta;
    truePhysVars[PHYSVAR::DELPT]  = deltaPt;

    // apply cuts
    const Bool_t hasSiSeed    = (nmaps == 3);
    const Bool_t hasTpcSeed   = (nmaps == 0);
    const Bool_t isPrimary    = (gprimary == 1);
    const Bool_t isWeirdTrack = ((ptFrac < normalPtFracMin) || (ptFrac > normalPtFracMax));
    const Bool_t isGoodTrk    = ApplyCuts(isPrimary, (UInt_t) nlmaps, vz, umDcaXY, umDcaZ, quality);
    if (!isGoodTrk) continue;

    // fill histograms
    FillTrackHistograms(TYPE::TRACK, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
    FillTruthHistograms(TYPE::TRUTH, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
 
    // fill embed_only weird histograms
    if (isWeirdTrack) {
      FillTrackHistograms(TYPE::WEIRD_ALL, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
      if (hasSiSeed)  FillTrackHistograms(TYPE::WEIRD_SI,  recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
      if (hasTpcSeed) FillTrackHistograms(TYPE::WEIRD_TPC, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
    } else {
      FillTrackHistograms(TYPE::NORMAL, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
    }
  }  // end embed-only entry loop
  cout << "      Finished embed-only entry loop." << endl;

  // prepare for with-pileup entry loop
  Long64_t nEntriesPU = ntTrkPU -> GetEntries();
  cout << "      Beginning with-pileup entry loop: " << nEntriesPU << " entries to process..." << endl;

  // loop over with-pileup tuple entries
  Long64_t nBytesPU(0);
  for (Long64_t iEntry = 0; iEntry < nEntriesPU; iEntry++) {

    // grab entry
    const Long64_t bytesPU = ntTrkPU -> GetEntry(iEntry);
    if (bytesPU < 0.) {
      cerr << "WARNING: something wrong with with-pileup entry #" << iEntry << "! Aborting loop!" << endl;
      break;
    }
    nBytesPU += bytesPU;

    // announce progress
    const Long64_t iProg = iEntry + 1;
    if (iProg == nEntriesPU) {
      cout << "        Processing with-pileup entry " << iProg << "/" << nEntriesPU << "..." << endl;
    } else {
      cout << "        Processing with-pileup entry " << iProg << "/" << nEntriesPU << "...\r" << flush;
    }

    // perform calculations
    const Double_t umDcaXY    = pu_dca3dxy * 10000;
    const Double_t umDcaZ     = pu_dca3dz * 10000;
    const Double_t deltaDcaXY = abs(pu_dca3dxysigma / pu_dca3dxy);
    const Double_t deltaDcaZ  = abs(pu_dca3dzsigma / pu_dca3dz);
    const Double_t deltaEta   = abs(pu_deltaeta / pu_eta);
    const Double_t deltaPhi   = abs(pu_deltaphi / pu_phi);
    const Double_t deltaPt    = abs(pu_deltapt / pu_pt);

    // check if values are defined
    const Bool_t thereAreNans = (isnan(pu_dca3dxy) || isnan(pu_dca3dz) || isnan(pu_eta) || isnan(pu_phi) || isnan(pu_pt));
    if (thereAreNans) continue;

    // set reco track variables
    recoTrkVars[TRKVAR::VX]       = pu_vx;
    recoTrkVars[TRKVAR::VY]       = pu_vy;
    recoTrkVars[TRKVAR::VZ]       = pu_vz;
    recoTrkVars[TRKVAR::NMMS]     = (Double_t) pu_nlmms;
    recoTrkVars[TRKVAR::NMAP]     = (Double_t) pu_nlmaps;
    recoTrkVars[TRKVAR::NINT]     = (Double_t) pu_nlintt;
    recoTrkVars[TRKVAR::NTPC]     = (Double_t) pu_ntpc;
    recoTrkVars[TRKVAR::QUAL]     = pu_quality;
    recoTrkVars[TRKVAR::DCAXY]    = umDcaXY;
    recoTrkVars[TRKVAR::DCAZ]     = umDcaZ;
    recoTrkVars[TRKVAR::DELDCAXY] = deltaDcaXY;
    recoTrkVars[TRKVAR::DELDCAZ]  = deltaDcaZ;
    recoTrkVars[TRKVAR::NCLUST]   = 0.;
    recoTrkVars[TRKVAR::AVGCLUST] = 0.;

    // set true track variables
    trueTrkVars[TRKVAR::VX]       = pu_gvx;
    trueTrkVars[TRKVAR::VY]       = pu_gvy;
    trueTrkVars[TRKVAR::VZ]       = pu_gvz;
    trueTrkVars[TRKVAR::NMMS]     = (Double_t) pu_gnlmms;
    trueTrkVars[TRKVAR::NMAP]     = (Double_t) pu_gnlmaps;
    trueTrkVars[TRKVAR::NINT]     = (Double_t) pu_gnlintt;
    trueTrkVars[TRKVAR::NTPC]     = (Double_t) pu_gntpc;
    trueTrkVars[TRKVAR::QUAL]     = pu_quality;
    trueTrkVars[TRKVAR::DCAXY]    = umDcaXY;
    trueTrkVars[TRKVAR::DCAZ]     = umDcaZ;
    trueTrkVars[TRKVAR::DELDCAXY] = deltaDcaXY;
    trueTrkVars[TRKVAR::DELDCAZ]  = deltaDcaZ;
    trueTrkVars[TRKVAR::NCLUST]   = 0.;
    trueTrkVars[TRKVAR::AVGCLUST] = 0.;

    // set reco phys variables
    recoPhysVars[PHYSVAR::PHI]    = pu_phi;
    recoPhysVars[PHYSVAR::ETA]    = pu_eta;
    recoPhysVars[PHYSVAR::PT]     = pu_pt;
    recoPhysVars[PHYSVAR::DELPHI] = deltaPhi;
    recoPhysVars[PHYSVAR::DELETA] = deltaEta;
    recoPhysVars[PHYSVAR::DELPT]  = deltaPt;

    // set true phys variables
    truePhysVars[PHYSVAR::PHI]    = gphi;
    truePhysVars[PHYSVAR::ETA]    = geta;
    truePhysVars[PHYSVAR::PT]     = gpt;
    truePhysVars[PHYSVAR::DELPHI] = deltaPhi;
    truePhysVars[PHYSVAR::DELETA] = deltaEta;
    truePhysVars[PHYSVAR::DELPT]  = deltaPt;

    // apply cuts
    const Bool_t isPrimary = (pu_gprimary == 1);
    const Bool_t isGoodTrk = ApplyCuts(isPrimary, (UInt_t) pu_nlmaps, pu_vz, umDcaXY, umDcaZ, pu_quality);
    if (!isGoodTrk) continue;

    // fill histograms
    FillTrackHistograms(TYPE::PILEUP, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
    if (isPrimary) {
      FillTrackHistograms(TYPE::PRIMARY, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
    } else {
      FillTrackHistograms(TYPE::NONPRIM, recoTrkVars, trueTrkVars, recoPhysVars, truePhysVars);
    }
  }  // end with-pileup entry loop
  cout << "      Finished with-pileup entry loop." << endl;

  // normalize histograms if needed
  if (doIntNorm) NormalizeHists();
  return;

}  // end Analyze()



void STrackCutStudy::End() {

  // announce method
  cout << "    Ending:" << endl;
  SetHistStyles();
  CreatePlots();
  SaveHists();

  // close files
  fOut  -> cd();
  fOut  -> Close();
  fInEO -> cd();
  fInEO -> Close();
  fInPU -> cd();
  fInPU -> Close();
  cout << "      Closed files.\n"
       << "  Finished track cut study!\n"
       << endl;
  return ;

}  // end End()

// end ------------------------------------------------------------------------
